<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Study on Rentseen&#39;s Blog</title>
    <link>http://yelinsheng.top/tags/study/index.xml</link>
    <description>Recent content in Study on Rentseen&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright &amp;copy; 叶林生 2016.</copyright>
    <atom:link href="http://yelinsheng.top/tags/study/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Machine Learning: Week 2</title>
      <link>http://yelinsheng.top/post/machine-learning-week2/</link>
      <pubDate>Tue, 06 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/machine-learning-week2/</guid>
      <description>

&lt;h1 id=&#34;machine-learning-week-2&#34;&gt;Machine Learning: Week 2&lt;/h1&gt;

&lt;h2 id=&#34;multivariate-linear-regression&#34;&gt;Multivariate linear regression&lt;/h2&gt;

&lt;p&gt;Linear regression with multiple variables is also known as &amp;ldquo;multivariate linear regression&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;notation&#34;&gt;Notation&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-1.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;hypothesis&#34;&gt;Hypothesis&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent&#34;&gt;Gradient descent&lt;/h3&gt;

&lt;p&gt;Formula:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-3.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Partial derivation will be like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-4.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;feature-scaling&#34;&gt;Feature scaling&lt;/h3&gt;

&lt;p&gt;If scale of features differ widely, it may take long time to converge. So it is
necessary to scale the feature.&lt;/p&gt;

&lt;p&gt;The contour will look like a circle after scaling.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Problem:&lt;/strong&gt; Is converge result which is scaled the same as converge result which is not scaled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-5.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If scale of feature is similar to [-1,1], it will be fine. When it is too big or too small, it should be scaled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-6.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Mean normalization:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-7.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;learning-rate&#34;&gt;Learning rate&lt;/h3&gt;

&lt;p&gt;Check if gradient descent works correctly using this plot: min(J) - iteration number.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-8.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Alpha can&amp;rsquo;t be too small or too big, we can check it using descent rate plot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-9.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;polynomial-regression&#34;&gt;Polynomial regression&lt;/h3&gt;

&lt;p&gt;We can combine multiple features into one, or use polynomial function.&lt;/p&gt;

&lt;p&gt;Convert it into linear regression, but range of variables may differ widely, so it need feature scaling.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-2-10.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;computing-parameters-analytically&#34;&gt;Computing parameters analytically&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Vim 的使用与学习</title>
      <link>http://yelinsheng.top/post/vim/</link>
      <pubDate>Tue, 06 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/vim/</guid>
      <description>

&lt;h1 id=&#34;vim-的使用与学习&#34;&gt;Vim 的使用与学习&lt;/h1&gt;

&lt;p&gt;据说大神都在用Vim，为了把右手从鼠标上解放出来，我也来入这个坑把。。。&lt;/p&gt;

&lt;h2 id=&#34;网站资源&#34;&gt;网站资源&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.openvim.com/&#34;&gt;openvim&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;shortcut&#34;&gt;shortcut&lt;/h2&gt;

&lt;p&gt;i / esc: insert模式和nomal模式的切换&lt;br /&gt;
h/j/k/l: left/down/up/right&lt;br /&gt;
b: 到当前词的词首&lt;br /&gt;
w: 到下一词的开头&lt;br /&gt;
e: 到当前词的结尾&lt;br /&gt;
O: 在当前行插入一行&lt;br /&gt;
o: 在下一行插入新的一行&lt;br /&gt;
$: 到这一行的行尾&lt;br /&gt;
0: 到这一行的行首&lt;br /&gt;
3i: 插入的值×3&lt;br /&gt;
3+移动键: 移动的次数×3&lt;br /&gt;
/: 查找&lt;br /&gt;
%: 找到与当前括号匹配的括号&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unity 3d 学习、体验</title>
      <link>http://yelinsheng.top/post/unity-3d/</link>
      <pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/unity-3d/</guid>
      <description>

&lt;h1 id=&#34;游戏引擎-unity-3d-的初次学习以及体验&#34;&gt;游戏引擎：unity-3d 的初次学习以及体验&lt;/h1&gt;

&lt;p&gt;unity-3d 是由Unity Technologies开发的专业游戏引擎&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装：&lt;/h2&gt;

&lt;p&gt;支持mac和windows这两个平台，我使用的是windows，直接选择免费版的下载安装即可，在安装时需要登录并填写一个调查问卷（不知道是干嘛的==）。&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用：&lt;/h2&gt;

&lt;p&gt;我是学习了一下官网上的教程，做的是第一个案例：Roll a ball.（没做完- -）&lt;/p&gt;

&lt;p&gt;官网上的视频讲的很清楚，每一步的操作都解释的很明白，它的视频用的是youtube提供的接口（youtube的字幕太强大了，似乎是自动生成的，用了机器学习神马的，很精准）&lt;/p&gt;

&lt;h2 id=&#34;细节记录&#34;&gt;细节记录：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;元件都是包含在一个scene中的&lt;/li&gt;
&lt;li&gt;camera元件：视角&lt;/li&gt;
&lt;li&gt;光线元件，可以投射到地面上&lt;/li&gt;
&lt;li&gt;plane，一个平面&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总体感受&#34;&gt;总体感受：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;界面功能很强大，3d效果超棒&lt;/li&gt;
&lt;li&gt;图形是在软件上手动添加操作的&lt;/li&gt;
&lt;li&gt;可以通过给图形元件绑定script代码来添加元件的逻辑，从而操作元件。&lt;/li&gt;
&lt;li&gt;代码可以使用 c# 或 javascript&lt;/li&gt;
&lt;li&gt;整个操作体验更像是设计和代码的结合（Dreamweaver？。。。）&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Machine Learning: Week 1</title>
      <link>http://yelinsheng.top/post/mathine-learning-week1/</link>
      <pubDate>Wed, 30 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/mathine-learning-week1/</guid>
      <description>

&lt;h1 id=&#34;machine-learning-week-1&#34;&gt;Machine Learning: Week 1&lt;/h1&gt;

&lt;h2 id=&#34;supervised-learning&#34;&gt;Supervised learning&lt;/h2&gt;

&lt;p&gt;Predict output according to the correct dataset which are already known.&lt;/p&gt;

&lt;p&gt;Supervised learning problems are categorized into &amp;ldquo;regression&amp;rdquo; and &amp;ldquo;classification&amp;rdquo; problems&lt;/p&gt;

&lt;h3 id=&#34;house-price-prediction&#34;&gt;House price prediction&lt;/h3&gt;

&lt;p&gt;This is a regression problem, whose prediction value is continuous.&lt;/p&gt;

&lt;p&gt;Do regression according to history data, you can do linear regression or quadratic regression which is up to you.&lt;/p&gt;

&lt;p&gt;Then do prediction using this result.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-1-1.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;breast-cancer&#34;&gt;Breast cancer&lt;/h3&gt;

&lt;p&gt;This is a classification problem, whose prediction value is discrete.&lt;/p&gt;

&lt;p&gt;Predict if tumor is benign or malignant according to tumor size. This is a classification problem.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-1-2.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When there are two feature: tumor size and age, it will be like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-1-3.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;unsupervised-learning&#34;&gt;Unsupervised learning&lt;/h2&gt;

&lt;p&gt;Find data structure from given dataset which do not have right answer.&lt;/p&gt;

&lt;h3 id=&#34;clustering-problem&#34;&gt;Clustering problem&lt;/h3&gt;

&lt;p&gt;Cluster these data into two parts.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-4.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An application: google news will cluster different news from different site but with same topic together.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-5.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Application of Unsupervised learning.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cluster the servers to make it more efficient&lt;/li&gt;
&lt;li&gt;Cluster the user in social network&lt;/li&gt;
&lt;li&gt;Market segmentation&lt;/li&gt;
&lt;li&gt;Astronomical data analysis
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-6.png&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cocktail party: Identify the voice from a mesh of sounds in chaotic environment.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-7.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;model-and-cost-function&#34;&gt;Model and Cost Function&lt;/h2&gt;

&lt;h3 id=&#34;notation&#34;&gt;Notation&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-1-8.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;model&#34;&gt;Model&lt;/h3&gt;

&lt;p&gt;why use hypothesis to represent function h: Former research used it, maybe it is not the best choice, but it just a terminology.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-9.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cost-function&#34;&gt;Cost Function&lt;/h3&gt;

&lt;p&gt;theta 1 and theta 0 are parameters of function h.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-10.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Something I don&amp;rsquo;t know before:&lt;/strong&gt;&lt;br /&gt;
#: hash sign, represent the number of something.&lt;br /&gt;
1/m: 1 over | the 2m&lt;/p&gt;

&lt;p&gt;The figure as follow shows the detail of cost function &lt;em&gt;J&lt;/em&gt; of linear regression function, which can be call squared error function.&lt;/p&gt;

&lt;p&gt;The mean is halved (1/2m) as a convenience for the computation of the gradient descent, as the derivative term of the square function will cancel out the 12 term
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-11.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intuition of cost function:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One parameter:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-12.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Two parameters:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-13.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;parameter-learning&#34;&gt;Parameter learning&lt;/h2&gt;

&lt;h3 id=&#34;gradient-descent&#34;&gt;Gradient Descent&lt;/h3&gt;

&lt;p&gt;Init theta 0 and theta 1, change these two values till J reaches local minimum value.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-14.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Different start position can lead to different local optimal.&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;&lt;img src=&#34;http://yelinsheng.top/img/ML-1-15.png&#34; alt=&#34;image&#34; /&gt;&lt;/dt&gt;
&lt;/dl&gt;

&lt;p&gt;:= is assignment; = is truth assertion.&lt;br /&gt;
Right side of equation should be updated simultaneously.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-16.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent-intuition&#34;&gt;Gradient Descent Intuition&lt;/h3&gt;

&lt;p&gt;Case of one parameter:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-17.png&#34; alt=&#34;image&#34; /&gt;
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-18.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The step will be smaller and smaller, so there is no need to decrease alpha.
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-19.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient-descent-for-linear-regression&#34;&gt;Gradient Descent for Linear Regression&lt;/h3&gt;

&lt;p&gt;Calculate partial derivation of J:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-20.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Gradient descent algorithm for linear regression:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-21.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Process of descent for linear regression
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-22.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Batch gradient descent: calculate all data in every update, high cost:
&lt;img src=&#34;http://yelinsheng.top/img/ML-1-23.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo tips记录</title>
      <link>http://yelinsheng.top/post/hugo/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/hugo/</guid>
      <description>

&lt;h2 id=&#34;编译的路径&#34;&gt;编译的路径&lt;/h2&gt;

&lt;p&gt;layouts/indexes下的html文件会被编译到一个单独的路径中，作为索引&lt;/p&gt;

&lt;p&gt;也可以用以下代码在config中强行指定索引文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[indexes]
  tag = &amp;quot;tags&amp;quot;
  topic = &amp;quot;topics&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md渲染&#34;&gt;md渲染&lt;/h2&gt;

&lt;p&gt;默认是按_default下的single.html来渲染的&lt;/p&gt;

&lt;h2 id=&#34;render模板指令&#34;&gt;render模板指令&lt;/h2&gt;

&lt;p&gt;默认是从_default目录中寻找的&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>htmlpy框架学习</title>
      <link>http://yelinsheng.top/post/htmlpy/</link>
      <pubDate>Tue, 11 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/htmlpy/</guid>
      <description>

&lt;h1 id=&#34;notes-for-htmlpy&#34;&gt;Notes for htmlpy&lt;/h1&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Ubuntu 16.04 LTS&lt;/p&gt;

&lt;p&gt;1) Installing python package manager: pip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) Installing htmlPy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install htmlPy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) Installing PySide&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-pyside
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) Installing jinja2, which is depended by htmlPy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo pip install jinja2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) Installing PyQt4&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python-qt4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-simple-demo&#34;&gt;A simple demo&lt;/h2&gt;

&lt;p&gt;Assume that there is a file named &amp;ldquo;index.html&amp;rdquo; in the same path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import htmlPy
import os

app = htmlPy.AppGUI(title=u&amp;quot;htmlPy Quickstart&amp;quot;, maximized=True)

app.template_path = os.path.abspath(&amp;quot;.&amp;quot;)
app.static_path = os.path.abspath(&amp;quot;.&amp;quot;)

app.template = (&amp;quot;index.html&amp;quot;, {&amp;quot;username&amp;quot;: &amp;quot;htmlPy_user&amp;quot;})

app.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;modularization&#34;&gt;Modularization&lt;/h2&gt;

&lt;p&gt;The driver file structure should be:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Initial configurations&lt;/li&gt;
&lt;li&gt;htmlPy GUI initialization&lt;/li&gt;
&lt;li&gt;htmlPy GUI configuration&lt;/li&gt;
&lt;li&gt;Binding of back-end functionalities with GUI
a. Import back-end functionalities
b. Bind imported functionalities&lt;/li&gt;
&lt;li&gt;Instructions for running front-end in if __name__ \=\= &amp;ldquo;__main__&amp;ldquo;: conditional. Always keep the GUI starter code in the &lt;code&gt;if __name__ == “__main__”:&lt;/code&gt; conditional. The GUI has to be started only when the driver file is running, not when it is being imported&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import htmlPy
from PyQt4 import QtGui


# Initial confiurations
BASE_DIR = os.path.abspath(os.path.dirname(__file__))


# GUI initializations
app = htmlPy.AppGUI(title=u&amp;quot;Application&amp;quot;, maximized=True, plugins=True)


# GUI configurations
app.static_path = os.path.join(BASE_DIR, &amp;quot;static/&amp;quot;)
app.template_path = os.path.join(BASE_DIR, &amp;quot;templates/&amp;quot;)

app.web_app.setMinimumWidth(1024)
app.web_app.setMinimumHeight(768)
app.window.setWindowIcon(QtGui.QIcon(BASE_DIR + &amp;quot;/static/img/icon.png&amp;quot;))

# Binding of back-end functionalities with GUI

# Import back-end functionalities
from html_to_python import ClassName

# Register back-end functionalities
app.bind(ClassName())


# Instructions for running application
if __name__ == &amp;quot;__main__&amp;quot;:
    # The driver file will have to be imported everywhere in back-end.
    # So, always keep app.start() in if __name__ == &amp;quot;__main__&amp;quot; conditional
    app.start()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43; multithreading学习</title>
      <link>http://yelinsheng.top/post/cplusplus-multithread/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/cplusplus-multithread/</guid>
      <description>

&lt;h1 id=&#34;c-concurrency-in-action&#34;&gt;c++ concurrency in action&lt;/h1&gt;

&lt;h2 id=&#34;g-compile&#34;&gt;g++ compile&lt;/h2&gt;

&lt;p&gt;g++ -std=c++11 launch-thread.cpp -o launch-thread -lpthread&lt;/p&gt;

&lt;h2 id=&#34;basic-thread-management&#34;&gt;basic thread management&lt;/h2&gt;

&lt;h3 id=&#34;lanch-a-thread&#34;&gt;lanch a thread&lt;/h3&gt;

&lt;p&gt;we can lanch a thread by passing a parameter which can be function, lamda expression and function call operator&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;thread&amp;gt;

void helloWorld(){
	std::cout&amp;lt;&amp;lt;&amp;quot;hello world from function&amp;quot;&amp;lt;&amp;lt;std::endl;
}

class hello{
	public:
		void operator()(){
			std::cout&amp;lt;&amp;lt;&amp;quot;hello world from function call operator&amp;quot;&amp;lt;&amp;lt;std::endl;
		}
};

int main(){
	std::thread testFunction(helloWorld);

	std::thread testLamda([]{
		std::cout&amp;lt;&amp;lt;&amp;quot;hello world from lamda&amp;quot;&amp;lt;&amp;lt;std::endl;
	});

	hello x;
	std::thread testCall(x);

	testFunction.join();
	testLamda.join();
	testCall.join();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wait-all-let-it-run&#34;&gt;wait all let it run&lt;/h3&gt;

&lt;p&gt;using join(), local thread will wait until thread to finished.&lt;/p&gt;

&lt;p&gt;using detach(), thread will continue run even if local thread is destroyed&lt;/p&gt;

&lt;h3 id=&#34;waiting-in-exceptional-circumstances&#34;&gt;Waiting in exceptional circumstances&lt;/h3&gt;

&lt;p&gt;thread_guard will be destroyed before thread, so join() will be called in destructor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;thread&amp;gt;

class thread_guard{
	std::thread &amp;amp;t;
	public:
		thread_guard(std::thread &amp;amp;t_):t(t_){
		}
		~thread_guard(){
			if(t.joinable()){
				t.join();
			}
		}
};

int main(){
	std::thread t([](){
		std::cout&amp;lt;&amp;lt;&amp;quot;hello&amp;quot;&amp;lt;&amp;lt;std::endl;
	});
	thread_guard g(t);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;passing-argument&#34;&gt;passing argument&lt;/h3&gt;

&lt;p&gt;argument is passed by pass a copy into internal storage. If pass a reference, we should use std::ref.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;thread&amp;gt;
void func(int &amp;amp;x){
	x++;
	x++;
}
int main(){
	int x=10;
	std::thread t(func,std::ref(x));
	t.join();
	std::cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;thread-management&#34;&gt;thread management&lt;/h2&gt;

&lt;h3 id=&#34;hardware-concurrency&#34;&gt;hardware_concurrency&lt;/h3&gt;

&lt;p&gt;This function returns an indication of the number of threads that can truly run concurrently for a given execution of a program. On a multicore system it might be the number of CPU cores, for example.
demo show as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
int main(){
	std::cout&amp;lt;&amp;lt;std::thread::hardware_concurrency()&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;thread-id&#34;&gt;thread id&lt;/h3&gt;

&lt;p&gt;the identifier for a thread can be obtained from its associated std::thread object by calling the get_id() member function;the identifier for the current thread can be obtained by calling std::this_thread::get_id().
demo show as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
int main(){
	std::cout&amp;lt;&amp;lt;std::this_thread::get_id()&amp;lt;&amp;lt;std::endl;
	std::thread a([]{
		std::cout&amp;lt;&amp;lt;&amp;quot;hello world&amp;quot;&amp;lt;&amp;lt;std::endl;
	});
	std::cout&amp;lt;&amp;lt;a.get_id()&amp;lt;&amp;lt;std::endl;
	a.join();
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sharing-data-between-threads&#34;&gt;sharing data between threads&lt;/h2&gt;

&lt;h3 id=&#34;race-condition&#34;&gt;race condition&lt;/h3&gt;

&lt;p&gt;几个线程的操作同时修改某个对象产生的问题。&lt;/p&gt;

&lt;p&gt;解决这个问题有三种方法：当某个线程在修改时，不允许其他线程介入；lock-free programming（复杂）;transaction(c++不支持)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>c&#43;&#43;函数</title>
      <link>http://yelinsheng.top/post/cplusplus-functions/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/cplusplus-functions/</guid>
      <description>

&lt;h1 id=&#34;函数用法&#34;&gt;函数用法&lt;/h1&gt;

&lt;h2 id=&#34;function-call-operator&#34;&gt;function call operator&lt;/h2&gt;

&lt;p&gt;在class中加入operator()使类具有函数的特征&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
class mul{
	public:
		mul(int x){
			multiplier=x;
		}
		int operator()(int x) const {
			return x*multiplier;
		}
	private:
		int multiplier;
};
int main(){
	mul test(10);
	std::cout&amp;lt;&amp;lt;test(2)&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lamda-expression&#34;&gt;lamda expression&lt;/h2&gt;

&lt;p&gt;[传入的变量列表](函数参数){函数体}(调用);&lt;/p&gt;

&lt;p&gt;在[ ]中声明需要使用的调用体的域中的本地变量，全局变量不需要声明。[=]表示所有的变量以赋值的形式传入，[&amp;amp;]表示所有的变量以引用的形式传入，[=,&amp;amp;j]表示除j外都以赋值传入，[i,&amp;amp;j]，表示i以赋值传入，j以引用传入&lt;/p&gt;

&lt;p&gt;第一个()为参数列表&lt;/p&gt;

&lt;p&gt;{}中是函数体&lt;/p&gt;

&lt;p&gt;第二个()表示调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
int main(){
	int x=1;
	double y=1.2;
	bool z=false;
	[x,&amp;amp;y](int i){std::cout&amp;lt;&amp;lt;i+x+y&amp;lt;&amp;lt;std::endl;}(1);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;accumulate&#34;&gt;accumulate&lt;/h2&gt;

&lt;p&gt;累加, demo 如下所示，可使用vector的迭代器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;numeric&amp;gt;

int main(){
    int can[]={1,2,3,4};
    int r=std::accumulate(can,can+4,0);
    std::cout&amp;lt;&amp;lt;r&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;distance&#34;&gt;distance&lt;/h2&gt;

&lt;p&gt;返回迭代器之间的距离，demo如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
int main(){
	char a[]={1,2,3,4,5};
	std::vector&amp;lt; int&amp;gt; b={1,2,3,4,5};
	std::cout&amp;lt;&amp;lt;std::distance(a,a+4)&amp;lt;&amp;lt;std::endl;
	std::cout&amp;lt;&amp;lt;std::distance(b.begin(), b.end())&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;advance&#34;&gt;advance&lt;/h2&gt;

&lt;p&gt;增加迭代器变量值，在list中应使用这个&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
int main(){
	std::vector&amp;lt;int&amp;gt; v={1,2,3,4,5};
	auto b= v.begin();
	std::advance(b,2);
	std::cout&amp;lt;&amp;lt;v[b-v.begin()]&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hash&#34;&gt;hash&lt;/h2&gt;

&lt;p&gt;对对象进行hash&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
int main(){
	std::hash&amp;lt;std::string&amp;gt; test;
	std::cout&amp;lt;&amp;lt;test(&amp;quot;hello&amp;quot;)&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find&#34;&gt;find&lt;/h2&gt;

&lt;p&gt;在容器中查找元素&lt;/p&gt;

&lt;h2 id=&#34;move&#34;&gt;move&lt;/h2&gt;

&lt;p&gt;将object转移给其他的变量，leaves the source object with a NULL pointer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;

int main(){
	std::string a=&amp;quot;abs&amp;quot;;
	std::cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl;
	std::string b=std::move(a);
	std::cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl&amp;lt;&amp;lt;b&amp;lt;&amp;lt;std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数传入参数-是否会拷贝副本的问题&#34;&gt;函数传入参数，是否会拷贝副本的问题&lt;/h2&gt;

&lt;p&gt;当调用函数时，在函数的scope中，一般使用的是参数的副本，即在执行函数体之前参数的copy版本会被传入，然而当参数是一个新建的对象而没用变量指向它时，它会直接传入调用的函数中去，而不会传入它的副本，以下代码可以验证这个问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;

class c{
	int a;
	public:
		c(int x):a(x){}
		c(const c &amp;amp;x){
			a=x.a;
			std::cout&amp;lt;&amp;lt;&amp;quot;copy constructor called&amp;quot;&amp;lt;&amp;lt;std::endl;
		}
};

void func(c x){
	std::cout&amp;lt;&amp;lt;&amp;quot;func called&amp;quot;&amp;lt;&amp;lt;std::endl;
}
int main(){
	c t(10);
	std::cout&amp;lt;&amp;lt;&amp;quot;object with name:&amp;quot;&amp;lt;&amp;lt;std::endl;
	func(t);
	std::cout&amp;lt;&amp;lt;&amp;quot;object without name:&amp;quot;&amp;lt;&amp;lt;std::endl;
	func(c(20));
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;std-mem-fn&#34;&gt;std::mem_fn&lt;/h2&gt;

&lt;p&gt;将类的成员保存在一个变量中之后调用，&amp;rdquo;Its functional call takes as first argument an object of type T (or a reference or a pointer to it) and, as additional arguments, the arguments taken by pm (if any). The effect of such a call with fn as first argument are the same as calling fn.*pm (or (*fn).*pm if fn is a pointer), forwarding any additional arguments.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;     // std::cout
#include &amp;lt;functional&amp;gt;   // std::mem_fn

struct int_holder {
	 int value;
	 int triple() {return value*3;}
};

int main () {
	 int_holder five {5};

	 // call member directly:
	 std::cout &amp;lt;&amp;lt; five.triple() &amp;lt;&amp;lt; &#39;\n&#39;;

	 // same as above using a mem_fn:
	 auto triple = std::mem_fn (&amp;amp;int_holder::triple);
	 std::cout &amp;lt;&amp;lt; triple(five) &amp;lt;&amp;lt; &#39;\n&#39;;

	 return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>linux bash学习</title>
      <link>http://yelinsheng.top/post/linux-bash/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/linux-bash/</guid>
      <description>

&lt;h1 id=&#34;linux-bash学习&#34;&gt;linux bash学习&lt;/h1&gt;

&lt;h2 id=&#34;chmod&#34;&gt;chmod&lt;/h2&gt;

&lt;p&gt;change mode, 改变文件的权限
&lt;a href=&#34;http://www.cnblogs.com/younes/archive/2009/11/20/1607174.html&#34;&gt;详情可见博客&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;hello world&lt;/h2&gt;

&lt;p&gt;demo 如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
#hello world
a=&amp;quot;hello world&amp;quot;
echo $a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-else&#34;&gt;if else&lt;/h2&gt;

&lt;p&gt;格式为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ ... ]; then
	  ...
elif [ ... ]; then
	  ...
else
	  ...
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;demo如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
#test if else

#-f ----&amp;gt; if is a file
a=&amp;quot;if-else.sh&amp;quot;
if [ -f $a ]; then
	echo &amp;quot;$a is a file&amp;quot;
else
	echo &amp;quot;$a is not a file&amp;quot;
fi

#-lt ----&amp;gt; less than -le -&amp;gt; less equal
b=4
if [ $b -lt 5 ]; then
	echo &amp;quot;$b is less than 5&amp;quot;
else
	echo &amp;quot;$b is great or equal than 5&amp;quot;
fi

#-x ----&amp;gt; if is executable
c=&amp;quot;if-else.sh&amp;quot;
if [ -x $c ]; then
	echo &amp;quot;$c is executable&amp;quot;
else
	echo &amp;quot;$c is not executable&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参数列表&#34;&gt;参数列表&lt;/h2&gt;

&lt;p&gt;$#表示包括$0在内的命令行参数的个数。在Shell中，脚本名称本身是$0，剩下的依次是$0、$1、$2…、${10}、${11}，等等。$*表示整个参数列表，不包括$0，也就是说不包括文件名的参数列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
#test parameters
echo $#
echo $0
echo $1
echo $*
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>mongodb学习</title>
      <link>http://yelinsheng.top/post/mogodb/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/mogodb/</guid>
      <description>

&lt;h2 id=&#34;指令&#34;&gt;指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;show dbs&lt;/strong&gt;  显示所有的数据库&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;db&lt;/strong&gt;  显示当前数据库下的集合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;use 数据库名&lt;/strong&gt; 切换数据库&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法复习</title>
      <link>http://yelinsheng.top/post/algorithm-review/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://yelinsheng.top/post/algorithm-review/</guid>
      <description>

&lt;h1 id=&#34;algorithm-course-review&#34;&gt;Algorithm course review&lt;/h1&gt;

&lt;h2 id=&#34;graph-algorithms&#34;&gt;Graph Algorithms&lt;/h2&gt;

&lt;h3 id=&#34;algorithm-on-graphs&#34;&gt;Algorithm on Graphs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;elementary graph algorithms

&lt;ol&gt;
&lt;li&gt;breadth-first search&lt;/li&gt;
&lt;li&gt;depth-first search&lt;/li&gt;
&lt;li&gt;minimum spanning tree&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;shortest path problem

&lt;ol&gt;
&lt;li&gt;single-source shortest path&lt;/li&gt;
&lt;li&gt;all-pairs shortest path&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;maximum flow

&lt;ol&gt;
&lt;li&gt;max-flow vs min-cut&lt;/li&gt;
&lt;li&gt;applications&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dfs&#34;&gt;DFS&lt;/h3&gt;

&lt;p&gt;time complexity: O(|V|+|E|)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>